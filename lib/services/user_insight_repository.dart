import 'dart:math';

import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:isar/isar.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../models/user_insight.dart';
import 'auth_service.dart';
import 'isar_service.dart';

/// Persists AI-generated user insights synced from Supabase.
///
/// Unlike [ServiceInsightRepository] (curated, same for all users),
/// these are personalised per-user insights generated by Claude Haiku.
/// Dismiss and read state sync back to Supabase (fire-and-forget).
///
/// Singleton following the same pattern as [ServiceInsightRepository].
class UserInsightRepository {
  UserInsightRepository._();
  static final instance = UserInsightRepository._();

  Isar get _isar => IsarService.instance.db;
  final _random = Random();

  bool get _hasSupabase =>
      const String.fromEnvironment('SUPABASE_URL').isNotEmpty;

  SupabaseClient get _client => Supabase.instance.client;

  /// Fetch the current user's non-dismissed insights from Supabase and
  /// upsert into Isar.
  ///
  /// Preserves local [isDismissed] and [isRead] flags on existing rows.
  /// Calls [cleanupExpired] after upsert to auto-hide stale insights.
  Future<void> syncFromSupabase() async {
    if (!_hasSupabase || !await _isOnline()) return;
    final uid = AuthService.instance.userId;
    if (uid == null) return;

    try {
      final rows = await _client
          .from('user_insights')
          .select()
          .eq('user_id', uid)
          .eq('is_dismissed', false);

      await _isar.writeTxn(() async {
        for (final row in rows) {
          final insight = UserInsight.fromSupabaseMap(row);

          // Preserve local flags on existing rows
          final existing = await _isar.userInsights
              .where()
              .remoteIdEqualTo(insight.remoteId)
              .findFirst();
          if (existing != null) {
            insight.id = existing.id;
            insight.isDismissed = existing.isDismissed;
            insight.isRead = existing.isRead;
          }

          await _isar.userInsights.put(insight);
        }
      });

      // Auto-hide expired insights
      await cleanupExpired();

    } catch (_) {
      // Silently ignored
    }
  }

  /// All non-dismissed, non-expired insights sorted by priority DESC
  /// then generatedAt DESC.
  List<UserInsight> getActiveInsights() {
    final now = DateTime.now();
    return _isar.userInsights
        .where()
        .filter()
        .isDismissedEqualTo(false)
        .and()
        .group((q) => q
            .expiresAtIsNull()
            .or()
            .expiresAtGreaterThan(now))
        .sortByPriorityDesc()
        .thenByGeneratedAtDesc()
        .findAllSync();
  }

  /// Highest-priority non-dismissed insight for a specific service.
  UserInsight? getInsightForService(String serviceKey) {
    final now = DateTime.now();
    return _isar.userInsights
        .where()
        .filter()
        .serviceKeyEqualTo(serviceKey)
        .and()
        .isDismissedEqualTo(false)
        .and()
        .group((q) => q
            .expiresAtIsNull()
            .or()
            .expiresAtGreaterThan(now))
        .sortByPriorityDesc()
        .findFirstSync();
  }

  /// Pick one random non-dismissed, non-expired insight.
  UserInsight? getRandomInsight() {
    final active = getActiveInsights();
    if (active.isEmpty) return null;
    return active[_random.nextInt(active.length)];
  }

  /// Mark an insight as dismissed locally and sync to Supabase
  /// (fire-and-forget).
  Future<void> dismissInsight(int isarId) async {
    final insight = await _isar.userInsights.get(isarId);
    if (insight == null) return;

    insight.isDismissed = true;
    await _isar.writeTxn(() async {
      await _isar.userInsights.put(insight);
    });

    // Fire-and-forget Supabase sync
    _syncDismiss(insight.remoteId);
  }

  /// Mark an insight as read locally and sync to Supabase
  /// (fire-and-forget, idempotent).
  Future<void> markAsRead(int isarId) async {
    final insight = await _isar.userInsights.get(isarId);
    if (insight == null || insight.isRead) return;

    insight.isRead = true;
    await _isar.writeTxn(() async {
      await _isar.userInsights.put(insight);
    });

    // Fire-and-forget Supabase sync
    _syncRead(insight.remoteId);
  }

  /// Mark all insights with expiresAt < now as dismissed.
  ///
  /// Called after every sync and at app startup.
  Future<void> cleanupExpired() async {
    final now = DateTime.now();
    final expired = _isar.userInsights
        .where()
        .filter()
        .isDismissedEqualTo(false)
        .and()
        .expiresAtIsNotNull()
        .and()
        .expiresAtLessThan(now)
        .findAllSync();

    if (expired.isEmpty) return;

    await _isar.writeTxn(() async {
      for (final insight in expired) {
        insight.isDismissed = true;
        await _isar.userInsights.put(insight);
      }
    });

  }

  /// Total insight count (for debug).
  int get count => _isar.userInsights.countSync();

  // ─── Private helpers ───

  Future<bool> _isOnline() async {
    final result = await Connectivity().checkConnectivity();
    return !result.contains(ConnectivityResult.none);
  }

  /// Best-effort dismiss sync to Supabase — no retry.
  void _syncDismiss(String remoteId) async {
    if (!_hasSupabase) return;
    try {
      await _client
          .from('user_insights')
          .update({'is_dismissed': true})
          .eq('id', remoteId);
    } catch (_) {
      // Silently ignored
    }
  }

  /// Best-effort read sync to Supabase — no retry.
  void _syncRead(String remoteId) async {
    if (!_hasSupabase) return;
    try {
      await _client
          .from('user_insights')
          .update({'is_read': true})
          .eq('id', remoteId);
    } catch (_) {
      // Silently ignored
    }
  }
}
